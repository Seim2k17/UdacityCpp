Concurrency in C++11

- multiple threads inm parallel = concurrency was first introduced in c++11

- before this third party libs (like BOOST) or native concurrency support from OS had to be implemented 
- the standardization of concurrency in C++ makes it possible to develop cross platform concurrent programs
- supported by including the thread header

- a running program consist of at least one thread -> main thread
-> threads are uniquely identified by the OS by thread ID

- to create more threads we use std::thread name(functionToCall)
-> to run it in parallel within a process and to wait for it that it correctly terminates we need to call .join() after implementation of the other code to call
-> see 03_example_3.cpp
- here .join() is used to ensure that main() waits for the thread t to finish

- in concurrent programming the behavior of the code is non-deterministic
-> it can't be predicted which thread the scheduler will execute next or at which point in time

Randomness of events
- an important characteristic of concurrency is the randomness execution of the code on different machines
-> we don't know when the scheduler will execute different threads
-> but we need to deal with it in a controlled manner

Using join() as a barrier
- if we want to avoid that the order of execution is determined by the scheduler
we can use .join() as a barrier

Detach
- if we don't join a thread before its destructor is called the program could crash
- there are situations where it makes no sense to wait for a thread to finish
-> for this we can use detach() method on the thread (see 06_example_6.cpp)
- a destructor of a detached thread does nothin , i neither blocks or terminate the thread
- a detached thread can never be joined again
-> so we need to be very careful with detach
-> we need to make sure that in the thread does not access any data that might get out of scope or deleted
-> and we do not want the program to terminate with threads still running
-> if so these threads will terminate without freein ressources

1.4. Starting a Thread with Function Object (Lambda)

- passing functions to functions is one form of a callable Object
- callable objects are objects that can appear as the left-hand operand of the call operator
-> these can be pointers to functions, objects of a class that defines an overloaded function call operator & lambdas (anonymous inline function)

- by passing functions to other without arguments the only way to make data available (e.g. other variables) would be to use global variables
-> def. not good

- we could use a instances of classes which implement the () operator
-> The "most vexing parse" comes from a rule in C++ that says that anything that could be considered as a function declaration, the compiler should parse it as a function declaration - even if it could be interpreted as something else.

std::thread t1( Vehicle() );
-> ambigous since it could be interpreted either as 
1. a variable definition for variable t of class std::thread, initialized with an anonymous instance of class Vehicle 
or
2. a function declaration for a function t that returns an object of type std::thread and has a single (unnamed) parameter that is a pointer to function returning an object of type Vehicle

There are three ways of forcing the compiler to consider the line as the first case, which would create the thread object we want:

a.Add an extra pair of parentheses
    std::thread t1( (Vehicle()) );

b.Use copy initialization
    std::thread t2 = std::thread( Vehicle() );

c.Use uniform initialization with braces
    std::thread t3{ Vehicle() };

