- to  use this from a shared_pointer one need to derive the wanted class also from std::enable_shared_from_this<CLASSTYPE>

-> to return the shared pointer one need do:

std::shared_ptr<Vehicle> get_shared_this() { return shared_from_this(); };

Promises & futures:
---------------------

- to pass data from the worker thread to the main thread we can use the concept of promises & future (send / receive end)

- to pass data from the main thread to the worker thread we can use variadic templates or Lambdas

- but to pass information from the worker thread back to the parent thread we need to adhere a strict synchronization protocol
-> single use channel  btw. threads: sending end of the channel: promise / receiving end: future

- std::promise can store an value or exception that will aquired by later time by a std::future
- std::promise - objects are meant to be used only once

-to obtain the corresponding future we need to call .get_future() at the promise object
- promises and futures are the types of communication we want to use to pass data between threads

- promises can not be copied because the promise-future concept is a 2 point communication channel for 1time use
-> ergo we need to use std::move

- with set_value() on the promise object to set the value
- and .get() on the future object to retrieve this value()
- this will block until data is available -> as soon as set_value has been called on the promise
-> if the result is movable it will be moved - otherwise is will be copied

- if set_value is called before get() -> get() will return data without any delay
- after get() has been called once, the future is no longer usable
-> this makes sense as normal mode of data exchange works with std::move() -> data is not available after first call, if called a second time an exception is thrown

--> see 21_promise_future.cpp


Quiz
----

- st its useful to separate the waiting for the content from the retrieving
- future allows this by using the wait() function -> this blocks until th future is ready
-> when it returns it is guaranteed that the data is reqady -> us get() to retrieve without delay
-> similar is wait_for() metzhod which takes a time duration as input and also waits for a result to become ready

-> see 22_quiz_get_vs_wait.cpp

Exceptions
-----

to pass exception over the future promise channel the future sets  an exception rather than an value

 catch (...)
    {
        prms.set_exception(std::current_exception());
    }

- so we can catch any exception & with e.what() we can get the message on the exception()

- disadvantages of promise/future
 1. one direction channel
 2. one time only usage


 Tasks vs. thread -> starting with async
 ----------------

 - to avoid much boilerplate-code for small functionality we can use tasks instead of threads (using std: async)
 - async generates a task -> system decides if to run in parallel or async
 -> the code can be parallized but the system decides

 - to uses async we ommit the promise and try/catch code in the thread function so that it looks like a normal function
 - we also replace std::thread with std::async which returns a future / nor promise is needed anymore
 - we still calling get() on the future but we dont need to call .join
 - with async the thread destructur will be called automatically -> this reduces the risk of a concurrency bug

 - with async we can use launch parameters so that we have influence if the cxode will be executed synchronously or async

 -> std::future<double> ftr = std::async(std::launch::deferred, ...)

 std::launch::deferred - synchronously
 std::launch::async - asynchronously (in parallel)
 std::async(std::launch::deferred | std::launch::async - let the system decide if sync or async execution of the program
 (st parallel execution even make runtime performance worse)

(25_async_thread_ids.cpp))
 - std::async internally it creates a promise. gets a future from it and runs a template function that takes the promise, calls our function & then sets the value or th exception

 - the code with std::async is more or less oidentical to the code, when using std::thread but its hidden from us, created by the compiler
 -> cleaner code and async makes it possible to control the amount of concurrency

 - to let the system decide allow us to prevent an overload of threads which could slow down the system
 -> if too many threads are used the increased resource conmsumption would outweight the advantages of parallelism and slow down the program
 -> the system choses threads carefully in a balanced way that optimizes runtrime performance

 Task-based concurrency (2.3)
 ---------------------

- determining the optional number of threads to use is a hard problem
-> depends usually on the number of available cores, wheter it makes sense to execute code as a thread or in sequence

- by using async (=== tasks) let the system decide whether to execute the code sequentially or as 
 .....


 Threads and tasks are used for different problems. Threads have more to do with latency. When you have functions that can block (e.g. file input, server connection), threads can avoid the program to be blocked, when e.g. the server is waiting for a response. Tasks on the other hand focus on throughput, where many operations are executed in paralle