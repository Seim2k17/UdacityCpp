
MUTEX
--------

-disdavantage of promise :
    - one use only
    - one directional
    -> until now ots not possible to freely exchange data infomartion btw. shared memory

- with mutexes/locks you can protect shared data from concurreent access and ensure that data can safely be written/tread from location

-> new issue arise: DEAD LOCKS

-> it would be much easiere to mutually access the shared mem location directyl (here: interection waiting queue)
-> concept of MUTuallyEXclusion does this
--> we can seafely lock a ressource , modify and the unlock it again if we're done

Using a Mutex To Protect Shared DataÂ¶
--------------------------

- Mutex entity:

- until now the moethiods we used to pass data btw. threads were short-term
-> we passed an argument (the promise) from a parent thread to a worker thread, tthen the result back to the parent thread (via the future) once it has become available
--> non permanent communication for one-time usage

- to avoid data races we need forego (verzichten) sahred data or use it in read-only access without mutating the data
- with MUTEX we want to establish a stable long term communication channel that allows for sharing and mutation
- ideally this should be done like in a radio channel ("over".. others turn) where sender and receiver can ttake turns in transmitting their data
- data races requires simultanious access from 2 threads
-> if we can guarantee that only a single thread at a time can access a particular memory location data races would not occur

-> therefore we need to establish a communication protocol

- a mutex is not the solution to the data race problem but an enabler for a thread safe communication

            shared mem
                |
              access
                |
underlock------mutex---x--is bloicked
    |                       |
 thread 1                 thread 2


- assuming we have a piece of memory we want to protect from simultaneous access
-> we can assign a mutex to be the guardian of this memory
- a mutex is bound to tthe memory it protects
- a thread 1 whi wants toi access the protected memory mustt "lock" the mutex first
- when thread 1 is under lock a thread 2 is blocked from access to the shared variable
- it can acquire the lock is is suspended by the system

- once reading or writing of thread1 is complete it must unlock the mutex so that tthread 2 can access the memory location
- the code under lock is often called "critical section"
- important : also read only access has to lock the mutex to prevent data_race (if another thread wantts tto modify)

- When several threads were to try to acquire and lock the mutex, only one of them would be successful
- all other threads would automatically be put on hold - just as cars waiting at an intersection for a green light 
- Once the thread who has succeeded in acquiring the lock had finished its job and unlocked the mutex, a queued thread waiting for access would be woken up and allowed to lock the mutex to proceed with his read / write operation
- if all threads were to follow this protocol, a data race would effectively be avoided
--> 32_mutex_1.cpp