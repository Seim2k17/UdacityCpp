6.3.1 RAII and smart pointers

- RAII reduces the risk of improperly managed resources
- it let us encapsulate new/delete calls within a class and give the programmer a clean interface
to the resource to use
- since c++11 there are smart pointers within the stl which build on this concept and revolutionizes the way we use resources on the heap
- they help to free programs from memory leaks

- with smart pointers RA occurs at the same time that the object is initialized
(instantiatet with make_shared or make_unique) 
-> all resources for the object are created and initialized within a single line

- in modern c++ raw pointers should only be used in small blocks of code with limited scope, where performance is crucial and ownership is clear

6.3.2.
- c++1 has introduced 3 types of smart pointers

    1. unique pointers (std::unique_ptr), 
    exclusivly ownes a dynamically allocated resource on the heap, no 2nd unique ptr to the same resource is allowed
    2. shared pointers (std::shared_ptr)
     point to a resource but does not explicitly own it, several shared ptrs to the same resource are allowed; each will increase an internal reference count; when the count reaches 0 the resource willa automatically be deallocated
    3. weak pointer (std::weak_ptr) behaves similar to the shared pointer but does not increase the reference count

prior to c+11 there was std::auto_ptr which is similar but deprecated and should not be used anymore

6.3.3. unique ptr

- exclusive owner of the memory resource it represents
- if there is a 2nd unique ptr to the resource there will be a compiler error
- as soon as the unique ptr goies out of scope, the mem resource is deallocated
- unique ptrs are useful when working with a temporary heap resource that is no longer needed when out of scope

auto sourcePtr = make_unique<MyObject>();   (sourcePtr--->heap resource)
auto destPtr = std::move(sourcePtr);        (destPtr--->heap resource)
-> a resource is managed by sourcePtr
-> the resource is reassigned using std::move to destPtr
-> resource is now owned by destPtr
-> sourcePtr can still be used but does not manage this resource anymore

unique ptr is constructed with std::make_unique<Type> p(new Type)

6.3.4. raw vs. unique

int *raw = new int;
*raw = 1;
delete raw:

std::make_unique<int> uniquePtr(new int);
*uniquePtr = 2;

-> take care to create unique ptrs  only on the stack otherwise the deallication won't work
-> initialized with a raw pointer to a heap allocated-object
-> the smart pointer destructor contains the call to delete
-> because its declared on the stack this destructor is invoked when the smart pointer gets out of scope-thus mem is deallocated automatically


6.3.5. video: smart ptr usage nd213-c03-l05-02.2-smart-pointers-sc_720p

- smaret pntrs are relativly easy to implement






