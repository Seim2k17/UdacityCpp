5.3. move semantics

- introduced in c++11
- rvalue refs is important prerequisite of understanding moving datastructures

        void myFunction(int &&val)
        {
            std::cout << "val = " << val << std::endl;
        }

        int main()
        {
            myFunction(42);

            return 0; 
        }

-> programmers msg: here the object that binds to the rvalue reference &&val is yours and not needed anymore by the scope of main
- passing values like this improves pereformance / no temporary copy needed
- ownership changes, the object the refernce binds to has been abandoned by the caller & now binds to a handle by the receiver
- with lvalue refs this would not possible: any chnage to the objects thats binds to the lvalue ref would also be visible on the caller side

- rvalues refs are themselves lvalues
- a reference is defined in a certain context (like val from above)
- Even though the object it refers to (the number 42) may be disposable in the context it has been created (the main function), 
it is not disposable in the context of the reference . So within the scope of myFunction, val is an lvalue as it gives access to the memory location 
where the number 42 is stored.
- however we can't pass an lvalue to myFunction ( an rvalue can't bind to an lvalue)
        
        int i = 23;
        myFunction(i) // would result in an error

--> std::move converts an rvalue into an rvalue (exactly: xvalue)

        int i = 23;
        myFunction(std::move(i))

--> i now is in the scope of myFunction not main
--> using std::move this way is one of the components of move semantics

5.3.3. Rule of 3

- it force you to carefully think about your mem-implementation
- one can make many errors in impl. an own mem-management-strategy
- to avoid this one can/must follow certain rules/guidelines

- it has been observed that impl. copy assignment operator/copy-cdor/destructor one have the need to manage memory manually
-> ruile-of-3: if you implement one of the 3 you have to implement the others as well
-> if you forget one the compiler will generate default versions and these would not reflect the memory managment strategy of the class
-> don't forget manuallyimplemented version, it's not recommended and will result in undefined behaviour

-> see 19_rule_of_three.cpp

- limitation of current design:
- we now consider another wayy of instantiating MoveableClass object by using createObject()
... see sourcefile

- like this implementation there are far to many copies involved this will make in inefficient esp. with big data structures! 
- before c++11 this would be solved by not returning copy by values
- since c+11 there is a more efficient way to even return large Datastrutures by value
--> move constructor and rule of 5


5.3.9. The move constructor
- basic idea is to steal the rvalue generated by the compiler during return by value operation and move expensive data in the source object to the target
-> not by copying but redicrecting data handles
-> moving data in such a way is always cheaper than making copies
-> move constructor + move assignment operator
- similar to the copy constructor
- move c'tor use a instance of a class as source, but after moving the source instance will no longer be usable afterwards

        // use an rvalue reference 
    MyMovableClass(MyMovableClass &&source) // 4 : move constructor
    {
        std::cout << "MOVING (câ€™tor) instance " << &source << " to instance " << this << std::endl;
        _data = source._data;
        _size = source._size;
        source._data = nullptr;
        source._size = 0;
    }        
- with implementing move-constructor and move assignement operator we've adhered the rule of 5
--> esp. important in memory management
--> all stl-containers like vector implement the rule of 5
--> if you have to implement one of the following functions you should implement the other wither proper implementation as well
        1. destructor (responsible for freeing resources)
        2. assignement operator (default performs a member wise shallow copy, if a deep copy is needed -> implement it)
        3. copy constructor ( as with the assignment op)

(proceed. 5.3.12)

