5.3. move semantics

- introduced in c++11
- rvalue refs is important prerequisite of understanding moving datastructures

        void myFunction(int &&val)
        {
            std::cout << "val = " << val << std::endl;
        }

        int main()
        {
            myFunction(42);

            return 0; 
        }

-> programmers msg: here the object that binds to the rvalue reference &&val is yours and not needed anymore by the scope of main
- passing values like this improves pereformance / no temporary copy needed
- ownership changes, the object the refernce binds to has been abandoned by the caller & now binds to a handle by the receiver
- with lvalue refs this would not possible: any chnage to the objects thats binds to the lvalue ref would also be visible on the caller side

- rvalues refs are themselves lvalues
- a reference is defined in a certain context (like val from above)
- Even though the object it refers to (the number 42) may be disposable in the context it has been created (the main function), 
it is not disposable in the context of the reference . So within the scope of myFunction, val is an lvalue as it gives access to the memory location 
where the number 42 is stored.
- however we can't pass an lvalue to myFunction ( an rvalue can't bind to an lvalue)
        
        int i = 23;
        myFunction(i) // would result in an error

--> std::move converts an rvalue into an rvalue (exactly: xvalue)

        int i = 23;
        myFunction(std::move(i))

--> i now is in the scope of myFunction not main
--> using std::move this way is one of the components of move semantics

5.3.3. Rule of 3

- it force you to carefully think about your mem-implementation
- one can make many errors in impl. an own mem-management-strategy
- to avoid this one can/must follow certain rules/guidelines

- it has been observed that impl. copy assignment operator/copy-cdor/destructor one have the need to manage memory manually
-> ruile-of-3: if you implement one of the 3 you have to implement the others as well
-> if you forget one the compiler will generate default versions and these would not reflect the memory managment strategy of the class
-> don't forget manuallyimplemented version, it's not recommended and will result in undefined behaviour

-> see 19_rule_of_three.cpp

- limitation of current design:
- we now consider another wayy of instantiating MoveableClass object by using createObject()
... see sourcefile

- like this implementation there are far to many copies involved this will make in inefficient esp. with big data structures! 
- before c++11 this would be solved by not returning copy by values
- since c+11 there is a more efficient way to even return large Datastrutures by value
--> move constructor and rule of 5


5.3.9. The move constructor
- basic idea is to steal the rvalue generated by the compiler during return by value operation and move expensive data in the source object to the target
-> not by copying but redicrecting data handles
-> moving data in such a way is always cheaper than making copies
-> move constructor + move assignment operator
- similar to the copy constructor
- move c'tor use a instance of a class as source, but after moving the source instance will no longer be usable afterwards

        // use an rvalue reference 
    MyMovableClass(MyMovableClass &&source) // 4 : move constructor
    {
        std::cout << "MOVING (câ€™tor) instance " << &source << " to instance " << this << std::endl;
        _data = source._data;
        _size = source._size;
        source._data = nullptr;
        source._size = 0;
    }        
- with implementing move-constructor and move assignement operator we've adhered the rule of 5
--> esp. important in memory management
--> all stl-containers like vector implement the rule of 5
--> if you have to implement one of the following functions you should implement the other wither proper implementation as well
        1. destructor (responsible for freeing resources)
        2. assignement operator (default performs a member wise shallow copy, if a deep copy is needed -> implement it)
        3. copy constructor ( as with the assignment op, the default copy constructor performs a shallow copy of the data members, if st. else is needed, the programmer has to implement it accordingly.
        4. move constructor: Because copying objects can be an expensive operation which involves creating, copying and destroying temporary objects, rvalue references are used to bind to an rvalue. Using this mechanism, the move constructor transfers the ownership of a resource from a (temporary) rvalue object to a permanent lvalue object.
        5. The move assignment operator: With this operator, ownership of a resource can be transferred from one object to another. The internal behavior is very similar to the move constructor.

When are move semantics used?

- where heavy-weight objects need to be passed around in a program (Copying these without move semantics can cause series performance issues)
-> the idea in this scenario is to create the object a single time and then "simply" move it around using rvalue references and move semantics.
- a second area of application are cases where ownership needs to be transferred (such as with unique pointers)
-> the primary difference to shared references is that with move semantics we are not sharing anything but instead we are ensuring through a smart policy that only a single object at a time has access to and thus owns the resource.

(20_rule_of_five.cpp w/o move semantics: Note that the compiler has been called with the option -fno-elide-constructors to turn off an optimization techniques called copy elision, which would make it harder to understand the various calls and the operations they entail. This technique is guaranteed to be used as of C++17, which is why we are also reverting to the C++11 standard for the remainder of this chapter using -std=c++11. Until now, no move operation has been performed yet as all of the above calls were involving lvalues. )

(slide 15: we can see that the temporary object at 0x7ffeefbff708 is moved to 0x7ffeefbff718 using the move assignment operator we wrote earlie should be (... 0x7ffc1ad9e0c0 is moved to 0x7ffc1ad9e0b)

-> with move semantics: 
(memory adress are different !
- looking at the stack addresses: we can see that the temporary object at 0x7ffeefbff708 is moved to 0x7ffeefbff718 using the move assignment operator,  the instance obj1 is assigned an rvalue (as expected from an rvalue, its destructor is called immediately afterwards)
- because we null its data pointer in the move constructor, the actual data will not be deleted
-> the advantage from a performance perspective in this case is that no deep-copy of the rvalue object needs to be made, we are simply redirecting the internal resource handle thus making an efficient shallow copy.)

Next, another temporary instance with a size of 1200 bytes is created as a temporary object and "assigned" to obj3. Note that while the call looks like an assignment, the move constructor is called under the hood, making the call identical to MyMovableClass obj2(MyMovableClass(300));. By creating obj3 in such a way, we are reusing the temporary rvalue and transferring ownership of its resources to the newly created obj3.
--> output says st different ? / there is no obj3 atm

(proceed. 5.3.16)

